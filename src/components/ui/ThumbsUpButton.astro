---
export interface Props {
  topicId: string;
  topicTitle: string;
  initialVoteCount?: number;
  className?: string;
  compact?: boolean;
}

const { topicId, topicTitle, initialVoteCount = 0, className = "", compact = false } = Astro.props;

// Different styles for compact (inline) vs full (standalone) mode
const buttonStyles = compact 
  ? `thumbs-up-btn flex items-center gap-1 px-2 py-1 bg-transparent border border-cyan-400 text-cyan-400 rounded hover:bg-cyan-400 hover:text-black transition-all duration-200 cursor-pointer text-sm ${className}`
  : `thumbs-up-btn flex items-center gap-2 px-3 py-2 bg-transparent border border-cyan-400 text-cyan-400 rounded-md hover:bg-cyan-400 hover:text-black transition-all duration-200 cursor-pointer whitespace-nowrap ${className}`;
---

<button 
  class={buttonStyles}
  data-topic-id={topicId}
  data-topic-title={topicTitle}
  data-initial-count={initialVoteCount}
  aria-label={`Vote for ${topicTitle}. Current votes: ${initialVoteCount}`}
  aria-describedby={`votes-${topicId}`}
  role="button"
>
  üëç <span class="vote-count font-bold" id={`votes-${topicId}`} aria-live="polite" aria-label={`${initialVoteCount} votes`}>
    {initialVoteCount}
  </span>
</button>

<script>
  async function trackVote(topicId, topicTitle) {
    // Track the vote in PostHog
    if (window.posthog) {
      window.posthog.capture('topic_vote', {
        topic_id: topicId,
        topic_title: topicTitle,
        timestamp: new Date().toISOString()
      });
    } else {
      console.warn('PostHog not available');
    }

    // Optimistic update (immediate UI feedback)
    const countElement = document.getElementById(`votes-${topicId}`);
    if (countElement) {
      const currentCount = parseInt(countElement.textContent) || 0;
      const newCount = currentCount + 1;
      countElement.textContent = newCount;
      countElement.setAttribute('aria-label', `${newCount} votes`);
    }

    // Fetch real count after delay to allow PostHog to process
    setTimeout(async () => {
      try {
        const response = await fetch(`/.netlify/functions/get-vote-counts?topicIds=${encodeURIComponent(topicId)}`);
        if (response.ok) {
          const data = await response.json();
          const realCount = data.voteCounts[topicId] || 0;

          if (countElement) {
            const currentDisplayCount = parseInt(countElement.textContent) || 0;

            // Only update if real count is higher (or significantly different) to avoid reverting optimistic updates
            if (realCount >= currentDisplayCount || Math.abs(realCount - currentDisplayCount) > 1) {
              countElement.textContent = realCount;
              countElement.setAttribute('aria-label', `${realCount} votes`);
            }
          }
        }
      } catch (error) {
        console.warn('Failed to fetch real vote count:', error);
      }
    }, 5000); // 5 second delay to allow PostHog processing
  }

  const handlerKey = '__howibuildThumbsUpClickHandler';
  const handleThumbsUpClick = (event) => {
    if (!(event?.target instanceof Element)) {
      return;
    }

    const button = event.target.closest('.thumbs-up-btn');
    if (!button) {
      return;
    }

    event.preventDefault();

    const topicId = button.dataset.topicId;
    const topicTitle = button.dataset.topicTitle;

    if (topicId && topicTitle) {
      trackVote(topicId, topicTitle);
    } else {
      console.error('Missing topic data on button:', button);
    }
  };

  // Use event delegation to handle clicks on any thumbs-up button, but only register once globally
  if (typeof window !== 'undefined' && !Reflect.get(window, handlerKey)) {
    Reflect.set(window, handlerKey, handleThumbsUpClick);
    document.addEventListener('click', handleThumbsUpClick);
  }
</script>

<style>
  .thumbs-up-btn {
    transition: all 0.2s ease;
  }
  
  .thumbs-up-btn:hover {
    transform: scale(1.05);
  }
  
  .thumbs-up-btn:active {
    transform: scale(0.95);
  }
</style>
